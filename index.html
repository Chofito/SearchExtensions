<!DOCTYPE html>
<html>

  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <meta name="description" content="SearchExtensions : Library of IQueryable and IEnumerable extension methods to perform searching">

    <link rel="stylesheet" type="text/css" media="screen" href="stylesheets/stylesheet.css">

    <title>SearchExtensions</title>
  </head>

  <body>


    <!-- HEADER -->
    <div id="header_wrap" class="outer">
      <header class="inner">
        <a id="forkme_banner" class="banner" href="https://github.com/ninjanye/SearchExtensions">View on GitHub</a>
        <a id="blog_banner" class="banner" href="http://jnye.co">Visit blog</a>

        <h1 id="project_title">SearchExtensions</h1>
        <h2 id="project_tagline">Library of IQueryable and IEnumerable extension methods to perform searching</h2>
        <section id="menu">
          <a href="index.html" class="menu selected">Home</a>
          <a href="releasehistory.html" class="menu">Release History</a>
        </section>
        <section id="downloads">
          <a class="zip_download_link" href="https://github.com/ninjanye/SearchExtensions/zipball/master">
            Download this project as a .zip file
          </a>
          <a class="tar_download_link" href="https://github.com/ninjanye/SearchExtensions/tarball/master">
            Download this project as a tar.gz file
          </a>
        </section>
      </header>
    </div>

    <!-- MAIN CONTENT -->
    <div id="main_content_wrap" class="outer">
      <section id="main_content" class="inner">
        <h3>
          This project is avaliable for download as a
          <a href="https://www.nuget.org/packages/NinjaNye.SearchExtensions/">
            nuget package
          </a>
          <p class="nuget-badge">
            <code>PM> Install-Package NinjaNye.SearchExtensions</code>
          </p>
        </h3>

        <h2 id="IQueryableSearch">IQueryable String Searching</h2>
        <h3>Methods</h3>
        <p>Search methods available to IQueryable data are:</p>
        <ul>
          <li>
            <code>Containing</code> - target property or properties
            <em>contains any</em> search term or terms
          </li>
          <li>
            <code>ContainingAll</code> - target property or properties
            <em>contains all</em> search terms
          </li>
          <li>
            <code>IsEqual</code> - target property or properties <em>equals</em>
            search term or terms
          </li>
          <li>
            <code>StartsWith</code> - target property or properties
            <em>starts with</em> search term or terms
          </li>
        </ul>

        <h3 id="ContainingSearch">
          Performing <code>Containing</code> searches
        </h3>
        <p>
          Search for a <strong>single search term</strong> within a
          <strong>single property</strong>
        </p>

<pre><code>var result = queryableData.Search(x =&gt; x.Property1)
                          .Containing("searchTerm");
</code></pre>

        <p>
          Search for a <strong>single search term</strong> within
          <strong>multiple properties</strong>
        </p>

<pre><code>var result = queryableData.Search(x =&gt; x.Property1,
                                  x =&gt; x.Property2,
                                  x =&gt; x.Property3)
                          .Containing("searchTerm");
</code></pre>

        <p>
          Search for <strong>multiple search terms</strong> within a
          <strong>single property</strong>
        </p>

<pre><code>var result = queryableData.Search(x =&gt; x.Property1)
                          .Containing("search", "term");
</code></pre>

        <p>
          Search for <strong>multiple search terms</strong> within
          <strong>multiple properties</strong>
        </p>

<pre><code>var result = queryableData.Search(x =&gt; x.Property1,
                                  x =&gt; x.Property2,
                                  x =&gt; x.Property3)
                          .Containing("searchTerm1",
                                      "searchTerm2",
                                      "searchTerm3");
</code></pre>

        <h3>Performing <code>Containing</code> AND searches</h3>
        <p>
          Search where a <strong>single property</strong> contains a
          <strong>single search term</strong><br>
          AND contains another <strong>single search term</strong>
        </p>

<pre><code>var result = queryableData.Search(x =&gt; x.Property1)
                          .Containing("searchTerm1")
                          .Containing("searchTerm2");
</code></pre>

        <p>
          Search where a <strong>single search term</strong> exists within in
          Property1 OR Property2<br>
          AND <strong>single search term</strong> exists within in Property3 OR
          Property4
        </p>

<pre><code>var result = queryableData.Search(x =&gt; x.Property1, x =&gt; x.Property2)
                          .Containing("searchTerm")
                          .Search(x =&gt; x.Property3, x =&gt; x.Property4)
                          .Containing("searchTerm");
</code></pre>

        <p>
          Search where a <strong>single search term</strong> exists in Property1
          OR Property2<br>
          AND any of the <strong>multiple search terms</strong> exist within a
          <strong>Property3</strong>
        </p>

<pre><code>var result = queryableData.Search(x =&gt; x.Property1, x =&gt; x.Property2)
                          .Containing("searchTerm")
                          .Search(x =&gt; x.Property3)
                          .Containing("another", "term");
</code></pre>

        <h3 id="ContainingAllSearch">
          Performing <code>ContainingAll</code> searches
        </h3>

        <p>
          Search where <strong>all search terms</strong> are within a
          <strong>single property</strong>
        </p>

<pre><code>var result = queryableData.Search(x =&gt; x.Property1)
                          .ContainingAll("search", "term");
</code></pre>

        <p>
          Search where <strong>all search terms</strong> exist across
          <strong>multiple properties</strong>
        </p>

<pre><code>var result = queryableData.Search(x =&gt; x.Property1,
                                  x =&gt; x.Property2,
                                  x =&gt; x.Property3)
                          .ContainingAll("search", "term");
</code></pre>

        <h3 id="IsEqualSearch">Performing <code>IsEqual</code> searches</h3>
        <p>
          Search where a <strong>single property</strong> equals a
          <strong>single search term</strong>
        </p>

<pre><code>var result = queryableData.Search(x =&gt; x.Property1)
                          .IsEqual("searchTerm");
</code></pre>

        <p>
          Search where any one of <strong>multiple properties</strong> is equal
          to a <strong>single search term</strong>
        </p>

<pre><code>var result = queryableData.Search(x =&gt; x.Property1,
                                  x =&gt; x.Property2,
                                  x =&gt; x.Property3)
                          .IsEqual("searchTerm");
</code></pre>

        <p>
          Search where a <strong>single property</strong> is equal to any one of
          <strong>multiple search terms</strong>
        </p>

<pre><code>var result = queryableData.Search(x =&gt; x.Property1)
                          .IsEqual("search", "term");
</code></pre>

        <p>
          Search where any one of <strong>multiple properties</strong> is equal
          to any one of <strong>multiple search terms</strong>
        </p>

<pre><code>var result = queryableData.Search(x =&gt; x.Property1,
                                  x =&gt; x.Property2,
                                  x =&gt; x.Property3)
                          .IsEqual("searchTerm1",
                                   "searchTerm2",
                                   "searchTerm3");
</code></pre>

        <h3 id="StartsWithSearch">
          Performing <code>StartsWith</code> searches
        </h3>
        <p>
          Search where a <strong>single property</strong> starts with a
          <strong>single search term</strong>
        </p>

<pre><code>var result = queryableData.Search(x =&gt; x.Property1)
                          .StartsWith("searchTerm");
</code></pre>

        <p>
          Search where any one of <strong>multiple properties</strong> starts
          with to a <strong>single search term</strong>
        </p>

<pre><code>var result = queryableData.Search(x =&gt; x.Property1,
                                  x =&gt; x.Property2,
                                  x =&gt; x.Property3)
                          .StartsWith("searchTerm");
</code></pre>

        <p>
          Search where a <strong>single property</strong> starts with any one of
          <strong>multiple search terms</strong>
        </p>

<pre><code>var result = queryableData.Search(x =&gt; x.Property1)
                          .StartsWith("search", "term");
</code></pre>

        <p>
          Search where any one of <strong>multiple properties</strong> starts
          with any one of <strong>multiple search terms</strong>
        </p>

<pre><code>var result = queryableData.Search(x =&gt; x.Property1,
                                  x =&gt; x.Property2,
                                  x =&gt; x.Property3)
                          .StartsWith("searchTerm1",
                                      "searchTerm2",
                                      "searchTerm3");
</code></pre>

        <h3 id="CombiningInstructions">Combining instructions</h3>
        <p>
          With the latest version of SearchExtensions you can also combine
          search actions. For instance:
        </p>

        <p>
          Search where a <strong>single property</strong>
          <code>starts with</code> a <strong>single search term</strong>
          AND <code>containing</code> a <strong>single search term</strong>
        </p>

<pre><code>var result = queryableData.Search(x =&gt; x.Property1)
                          .StartsWith("abc")
                          .Containing("mno");
</code></pre>

        <p>
          The ability to pass <strong>multiple search terms</strong> to any of
          the action methods still remains
        </p>

<pre><code>var result = queryableData.Search(x =&gt; x.Property1, x =&gt; x.Property2)
                          // that starts with "abc" OR "ninja"
                          .StartsWith("abc", "ninja")
                          // and contains "xyz" OR "extensions"
                          .Containing("xyz", "extensions")
</code></pre>

        <h2 id="IEnumerableSearch">IEnumerable (in memory) Searches</h2>
        <p>
          SearchExtensions has also been extended to support
          <code>IEnumerable</code> collections.
        </p>

        <p>
          This means you can now perform all of the above searches on in memory
          collections should you need to.
        </p>

        <h3>Methods</h3>
        <p>
          Currently <code>IEnumerable</code> searching has more features
          available to it than <code>IQueryable</code>, namely
          <code>EndsWith</code> and <code>SetCulture</code>
        </p>

        <ul>
          <li>
            <code>SetCulture</code> - Sets the string comparison culture with
            which to perform searches
          </li>
          <li>
            <code>Containing</code> - target property <em>contains</em> search
            term or terms
          </li>
          <li>
            <code>IsEqual</code> - target property <em>equals</em> search term
            or terms
          </li>
          <li>
            <code>StartsWith</code> - target property <em>starts with</em>
            search term or terms
          </li>
          <li>
            <code>EndsWith</code> - target property <em>ends with</em> search
            term or terms
          </li>
        </ul>

        <p>
          The important thing to remember when performing an in memory search is
          to set the culture to the type of string comparison you wish to
          perform.
          <strong>
            If <code>SetCulture</code> is not specified,
            <code>StringComparison.CurrentCulture</code> is used.
          </strong>
        </p>

        <h3>Performing IEnumerable searches</h3>
        <p>
          These methods are identical to that of the <code>IQueryable</code>
          methods.
        </p>

<pre><code>var result = enumerableData.Search(x =&gt; x.Property1)
                           // Set culture for comparison
                           .SetCulture(StringComparison.OrdinalIgnoreCase)
                           .StartsWith("abc")
                           .EndsWith("xyz")
                           .Containing("mno");
</code></pre>

        <p>
          It is also possible to switch the <code>StringComparison</code>
          culture context multiple times
        </p>

<pre><code>var result = enumerableData.Search(x =&gt; x.Property1)
                           .SetCulture(StringComparison.OrdinalIgnoreCase)
                           .StartsWith("abc")  // Uses OrdinalIgnoreCase
                           .SetCulture(StringComparison.Ordinal)
                           .EndsWith("xyz")    // Uses Ordinal
                           .SetCulture(StringComparison.CurrentCulture)
                           .Containing("mno"); //Uses CurrentCulture
</code></pre>

        <h2 id="RankedSearches">Ranked Searches</h2>
        <p>
          Another feature of the fluent api across both <code>IQueryable</code>
          and <code>IEnumerable</code> collections is the
          <code>ToRanked()</code> method.
        </p>
        <p>
          As well as returning the matched items, a Ranked Search also returns a
          hit count for each item in the form of an IRanked result. This enables
          you to order by hit count to retrieve the most relevant search results.
        </p>

        <h3 id="IRankedResult"><code>IRanked&lt;T&gt;</code> result</h3>
        <p>An IRanked result is simply defined as follows:</p>

<pre><code>public interface IRanked&lt;out T&gt;
{
    int Hits { get; }
    T Item { get; }
}
</code></pre>

        <p>This is returned using the <code>ToRanked()</code> method:</p>
        <p>
          RankedSearch for a <strong>single search term</strong> within a
          <strong>single property</strong>
        </p>

<pre><code>var result = queryableData.Search(x =&gt; x.Property1)
                          .Containing("searchTerm")
                          .ToRanked();
</code></pre>

        <p>
          RankedSearch for a <strong>single search term</strong> within
          <strong>multiple properties</strong>
        </p>

<pre><code>var result = queryableData.Search(x =&gt; x.Property1,
                                  x =&gt; x.Property2,
                                  x =&gt; x.Property3)
                          .Containing("searchTerm")
                          .ToRanked();
</code></pre>

        <p>
          RankedSearch for <strong>multiple search terms</strong> within a
          <strong>single property</strong>
        </p>

<pre><code>var result = queryableData.Search(x =&gt; x.Property1)
                          .Containing("searchTerm1",
                                      "searchTerm2",
                                      "searchTerm3")
                          .ToRanked();
</code></pre>

        <p>
          RankedSearch for <strong>multiple search terms</strong> within
          <strong>multiple properties</strong>
        </p>

<pre><code>var result = queryableData.Search(x =&gt; x.Property1, x =&gt; x.Property2)
                          .Containing("searchTerm1",
                                      "searchTerm2",
                                      "searchTerm3")
                          .ToRanked();
</code></pre>

        <h3>Retrieve most relevant search results</h3>
        <p>
          Using ranked search you can now easily order your search results by
          the most relevant.  This following example assumes we have a list of
          <code>User</code> which has <code>FirstName</code>,
          <code>LastName</code> and <code>MiddleName</code> string properties.
          In this example we want to match on those with "John" in their name
          and retrieve the top 10 results.
        </p>

<pre><code>var result = context.Users.Search(x =&gt; x.FirstName,
                                  x =&gt; x.LastName,
                                  x =&gt; x.MiddleName)
                          .Containing("John")
                          .ToRanked()
                          // Order by Hits property of IRanked&lt;User&gt;
                          .OrderByDescending(r =&gt; r.Hits)
                          .Take(10);
</code></pre>

        <h3>Mixing it up</h3>
        <p>We can also mix it up with the other fluent API methods</p>

<pre><code>var result = context.Users.Search(x =&gt; x.FirstName,
                                  x =&gt; x.LastName,
                                  x =&gt; x.MiddleName)
                          .StartsWith("john")
                          .Containing("nye")
                          .ToRanked()
                          // Order by Hits property of IRanked&lt;User&gt;
                          .OrderByDescending(r =&gt; r.Hits)
                          .Take(10);
</code></pre>

        <h3>A word of note</h3>
        <p>
          Be aware that the <code>ToRanked()</code> method uses the search terms of
          the <code>Containing()</code> method combined with the properties to
          search to build its hit count.  The fluent <code>ToRanked()</code> method.
        </p>

        <h2 id="SoundexSupport">Soundex support</h2>

        <p>
          As of Release 1.1,
          <a href="https://www.nuget.org/packages/NinjaNye.SearchExtensions/">
            NinjaNye.SearchExtensions
          </a>
          supports converting and searching for words that sound like a given
          word.
        </p>

        <h3 id="SoundexSearch">
          How to: Performing <code>Soundex</code> searches
        </h3>

        <p>
          Returning  records that 'sound like' "test" using the
          <a href="http://en.wikipedia.org/wiki/Soundex">Soundex algorythm</a>
        </p>

        <p>
          Search where a <strong>single property</strong> sounds like a
          <strong>single search term</strong>
        </p>

<pre><code>var result = data.Search(x =&gt; x.Property1).Soundex("test")
</code></pre>

        <p>
          Search where a any of <strong>multiple properties</strong> sounds like
          a <strong>single search term</strong>
        </p>

<pre><code>var result = data.Search(x =&gt; x.Property1, x =&gt; x.PropertyTwo)
                 .Soundex("test")
</code></pre>

        <p>
          Search where a <strong>single property</strong> sounds like any one of
          <strong>multiple search terms</strong>
        </p>

<pre><code>var result = data.Search(x =&gt; x.Property1)
                 .Soundex("test", "another")
</code></pre>

        <p>
          Search where a any of <strong>multiple properties</strong> sounds like
          any of <strong>multiple search terms</strong>
        </p>

<pre><code>var result = data.Search(x =&gt; x.Property1, x =&gt; x.PropertyTwo)
                 .Soundex("test", "another")
</code></pre>

        <blockquote>
          <p>
            The above methods can also be applied to <code>IQueryable</code>
            data. For <code>IQueryable</code> we reduce the amount of records
            returned from the data source as much as possible but be aware that
            the soundex searching is performed on the in memory collection.
          </p>
        </blockquote>

        <p>
          For more information about the Soundex search functionality, soundex
          search performance, and how it has been integrated with
          <code>IQueryable</code>, please visit
          <a href="http://jnye.co/soundex">http://jnye.co/soundex</a>
        </p>

        <hr>

        <blockquote>
          <p>
            And that is it.  If you have any new feature requests, questions, or
            comments, please get in touch, either, via my
            <a href="http://jnye.co">website</a>,
            <a href="https://twitter.com/ninjanye">twitter</a> or by creating an
            issue through the
            <a href="https://github.com/ninjanye/SearchExtensions/">
              projects github page
            </a>.
          </p>
        </blockquote>

    <!-- FOOTER  -->
    <div id="footer_wrap" class="outer">
      <footer class="inner">
        <p class="copyright">SearchExtensions maintained by
          <a href="https://github.com/ninjanye">ninjanye</a>
        </p>
        <p>Published with <a href="http://pages.github.com">GitHub Pages</a></p>
      </footer>
    </div>

  </body>
</html>
